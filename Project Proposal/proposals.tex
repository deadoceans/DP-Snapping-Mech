\documentclass[11pt]{exam}

% These are my most commonly-used LaTeX packages.
% You can add additional ones here as needed
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{fullpage}
\usepackage{times}
\usepackage{hyperref}
\usepackage{pdfsync}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{graphicx}

% Header.tex is a separate file 
\input{Header}

% Content for the file header, defined in Header.tex
\newcommand{\topic}{Generating Differentially Private
\\Laplacian Noise}
\newcommand{\displaydate}{September 26, 2017} 
\assignmentheader

% Only content between \begin{document} and \end{document} will be typeset
\begin{document} 
\bibliographystyle{alpha} 

\thispagestyle{head} % makes the file header appear on the first page


\section{Background}

The mathematical abstraction of the Laplacian mechanism differs greatly from its implementation in floating point representation.  In his paper, \textit{On Significance of the Least Significant Bits For Differential Privacy}, Mironov describes a new type of vulnerability present in implementations of the Laplacian mechanism. Specifically, this vulnerability results from the exploitation of the irregular distribution of the Laplacian mechanism resulting from finite precision and rounding effects of floating point operations.

Let's put this in more concrete terms by using an example of Laplacian sampling.  Say we have 10 double numbers, ranging from $x = 1/ \pi$ to $x+9 \cdot 2^{-54}$.  Applying the log function to each number in this set of 10 double numbers results in a transformation where some specific output numbers are more frequent than others.  Below is some code created to display this exact problem.  Notice how two numbers occur twice.

\includegraphics[width=\textwidth]{code.PNG}
\includegraphics{result.PNG}

Similarly, using a different set of numbers, another thing can happen - the distribution is not evenly distributed and some output values from an interval become missing.  This "porous distribution," as Mirinov calls it, is what causes a breach in differential privacy.

To show this in concrete terms, consider the Laplacian mechanism $\tilde{f}(\cdot)_{\epsilon,p} = f(D) + Lap*_p (\Delta/\epsilon)$, where $p$ is the precision with which the uniform distribution over $(0,1)$ is sampled.  Let $\Delta = 1$, $f(D) = 0$, and $f(D') = 1$.  Consider the distribution of $\tilde{f}^*(D)_{1/3} = 0 + Lap*(3)$ and $\tilde{f}^*(D')_{1/3} = 1 + Lap*(3)$ around 1.5.  As it turns out, the output of the Laplacian mechanism results in some different values for $\tilde{f}^*(D)$ and $\tilde{f}^*(D')$.  For example, an output of $\tilde{f}^*(D)$ includes the value $1.5$ while $\tilde{f}^*(D')$ does not.  Similarly, $\tilde{f}^*(D')$ includes the value $1.5 + 2 \cdot 2^{-52}$, while $\tilde{f}^*(D)$ does not.  This means if the output of the Laplacian mechanism is $1.5 + 2 \cdot 2^{-52}$, the input database was $D'$ etc.  Thus, differential privacy is violated.

The paper \textit{Fast and Correctly Rounded Logarithms in Double Precision} by Dinechin, Lauder, and Mueller presents an algorithm to round floating point numbers precisely, to preserve differential privacy. As seen above, there are issues distributing noise with floating point values as they are not precise and can expose data. This new algorithm can provide accuracy up to $2^{-150}$ if needed. The main structure of this algorithm is comprised of 2 steps. The first step provides accuracy up to $2^{-60}$. It executes some operation on the float and then performs a rounding test. If the rounding test passes, this means there is no error and the algorithm can terminate with accuracy $2^{-60}$. There is a small chance, however, that there are inconsistencies in the values. In this case, the second step is implemented. It uses predefined libraries based on processor type to provide more accuracy. The output of this step will then be converted to a double precision number and is guaranteed to have accuracy of at least $2^{-150}$. By determining a way to integrate this algorithm into the snapping mechanism, we can preserve differential privacy with floating point numbers.  

\section{Objectives} 

Mironov proposed something called the \textit{snapping mechanism} to yield a differentially private mechanism by solving the issue explained above.  It works by tossing out the lower bits of the Laplacian noise result \textit{after} adding the noise to the query.  Previously, our differentially private mechanism was defined as $\tilde{f}(D) = f(D) + Lap*_p (\Delta/\epsilon)$.  Using Mironov's snapping mechanism, we now define it to be

\begin{align}
    \tilde{f}(D) \triangleq clamp_{B}(\lfloor clamp_{B}(f(D)) \oplus S \otimes \lambda \otimes LN(U^{*})  \rceil_{\Lambda}) 
\end{align}
\begin{itemize}
    \item $U^{*}$ is the uniform distribution over $\mathbb{D} \cap(0,1)$ such that each double number is output with probability proportional to its ulp
    \item $S$ is uniform over ${-1,+1}$
    \item $LN(\cdot)$ denotes a floating point implementation of the natural logarithm with exact rounding 
    \item Function $clamp_{B}(x)$ outputs: (1) $B$ if $x>B$, (2)$-B$ if $x<-B$, (3)$x$ otherwise
    \item $\Lambda$ is the smallest power of 2 (including negative powers) $\geq$ $\Lambda$ 
    \item $\lfloor \cdot \rceil_{\Lambda}$ round to the closest multiple of $\Lambda$ in $\mathbb{D}$ with ties resolved towards $+\infty$
\end{itemize}

The primary goal of this project is to create a software tool which generates Laplacian noise in a differentially private way by using the above mechanism defined by Mironov.  Additionally, we hope to be able to integrate this tool into a larger software framework that is used for querying databases.

\section{Deliverables}

\begin{enumerate}
    \item \textbf{DP Laplacian Noise Generator using Rust Language}: The goal here is to create a program that can use floating point numbers and generate Laplacian Noise in a way that preserves differential privacy. Rust will be used since it is a secure language that provides all the necessary tools we may need to complete the algorithm.
        
    \item \textbf{Integrated Software}: Once we have the basic algorithm completed, the next step is to determine what pre-existing frameworks we could potentially integrate the tool with. The purpose of this would be to ensure differential privacy with large database systems. After researching what possibilities exist, we would then modify our code so that the tool could work hand in hand with the framework.
    \item \textbf{Software Documentation}: Next we need to provide adequate documentation for our code. The goal would be for any user to be able to read and understand the code so they could use it with a database they may have. The documentation would include not only in code comments, but also a guide to explain how it works.
    \item \textbf{Software Bindings for C/Python (optional)}: Many projects related to this work are in C/Python. To make our code more accessible and flexible, we could add bindings so that it will work no matter which language it is to be used with. 
    \item \textbf{GUI for Software Tool (optional)}: If time allows, we could also create a GUI to make our tool more user friendly. This way, when users have a database, they would not need many software skills/terminal knowledge. The GUI would guide them through the process of adding noise to their database.
\end{enumerate}

\section{Project Timeline}
\begin{enumerate}
    \item \textbf{DP Laplacian Noise Generator using Rust Language}: October 16th
    \item \textbf{Integrated Software}:November 17th
    \item \textbf{Software Documentation}:November 30th
    \item \textbf{Presentation}: November 30th
    \item \textbf{Software Bindings for C/Python (optional)}: If time allows
     \item \textbf{GUI for Software Tool (optional)}: If time allows
\end{enumerate}
    

\bibliography{sample} % this loads the bibliography
\cite{M}
\cite{DLM}

\end{document}